// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v3.19.1
// source: memory.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire"
import { Metadata, StringValue } from "./common"

/** Request and response messages */
export interface GetMemoryStatsRequest {
	metadata?: Metadata | undefined
}

export interface MemoryStatsResponse {
	totalMemories: number
	patternsByType: { [key: string]: number }
	conversationCount: number
	projectCount: number
	lastUpdated: number
	memoryUsage: number
}

export interface MemoryStatsResponse_PatternsByTypeEntry {
	key: string
	value: number
}

export interface GetCurrentProjectMemoryRequest {
	metadata?: Metadata | undefined
}

export interface ProjectMemoryResponse {
	projectId: string
	projectName: string
	projectPath: string
	lastUpdated: number
	context?: ProjectContext | undefined
	learnedPatterns: LearnedPattern[]
	conversationSummary?: ConversationSummary | undefined
	fileStructure?: FileStructureMemory | undefined
	userPreferences?: UserPreferences | undefined
}

export interface ProjectContext {
	technologies: string[]
	frameworks: string[]
	languages: string[]
	dependencies: { [key: string]: string }
	buildTools: string[]
	testingFrameworks: string[]
	codingStandards: string[]
	architecture: string[]
}

export interface ProjectContext_DependenciesEntry {
	key: string
	value: string
}

export interface LearnedPattern {
	id: string
	type: string
	description: string
	pattern: string
	context: string
	confidence: number
	createdAt: number
	lastUsed: number
	usageCount: number
	tags: string[]
}

export interface ConversationSummary {
	totalConversations: number
	topics: string[]
	frequentQuestions: string[]
	commonIssues: string[]
	successfulSolutions: string[]
	lastConversationTopics: string[]
}

export interface FileStructureMemory {
	importantFiles: string[]
	frequentlyModified: string[]
	filePurposes: { [key: string]: string }
	directories: string[]
	entryPoints: string[]
}

export interface FileStructureMemory_FilePurposesEntry {
	key: string
	value: string
}

export interface UserPreferences {
	codingStyle: string
	commentingStyle: string
	namingConventions: string[]
	preferredLibraries: string[]
	avoidancePatterns: string[]
	communicationStyle: string
}

export interface ClearProjectMemoryRequest {
	metadata?: Metadata | undefined
	projectId: string
}

export interface ExportMemoryRequest {
	metadata?: Metadata | undefined
	projectId: string
}

export interface ImportMemoryRequest {
	metadata?: Metadata | undefined
	projectId: string
	memoryJson: string
}

export interface AnalyzeConversationRequest {
	metadata?: Metadata | undefined
	messages: string[]
}

export interface GetRelevantContextRequest {
	metadata?: Metadata | undefined
	query: string
}

function createBaseGetMemoryStatsRequest(): GetMemoryStatsRequest {
	return { metadata: undefined }
}

export const GetMemoryStatsRequest: MessageFns<GetMemoryStatsRequest> = {
	encode(message: GetMemoryStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): GetMemoryStatsRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseGetMemoryStatsRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.metadata = Metadata.decode(reader, reader.uint32())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): GetMemoryStatsRequest {
		return { metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined }
	},

	toJSON(message: GetMemoryStatsRequest): unknown {
		const obj: any = {}
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<GetMemoryStatsRequest>, I>>(base?: I): GetMemoryStatsRequest {
		return GetMemoryStatsRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<GetMemoryStatsRequest>, I>>(object: I): GetMemoryStatsRequest {
		const message = createBaseGetMemoryStatsRequest()
		message.metadata =
			object.metadata !== undefined && object.metadata !== null ? Metadata.fromPartial(object.metadata) : undefined
		return message
	},
}

function createBaseMemoryStatsResponse(): MemoryStatsResponse {
	return {
		totalMemories: 0,
		patternsByType: {},
		conversationCount: 0,
		projectCount: 0,
		lastUpdated: 0,
		memoryUsage: 0,
	}
}

export const MemoryStatsResponse: MessageFns<MemoryStatsResponse> = {
	encode(message: MemoryStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.totalMemories !== 0) {
			writer.uint32(8).int32(message.totalMemories)
		}
		Object.entries(message.patternsByType).forEach(([key, value]) => {
			MemoryStatsResponse_PatternsByTypeEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join()
		})
		if (message.conversationCount !== 0) {
			writer.uint32(24).int32(message.conversationCount)
		}
		if (message.projectCount !== 0) {
			writer.uint32(32).int32(message.projectCount)
		}
		if (message.lastUpdated !== 0) {
			writer.uint32(40).int64(message.lastUpdated)
		}
		if (message.memoryUsage !== 0) {
			writer.uint32(48).int64(message.memoryUsage)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): MemoryStatsResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseMemoryStatsResponse()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.totalMemories = reader.int32()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					const entry2 = MemoryStatsResponse_PatternsByTypeEntry.decode(reader, reader.uint32())
					if (entry2.value !== undefined) {
						message.patternsByType[entry2.key] = entry2.value
					}
					continue
				}
				case 3: {
					if (tag !== 24) {
						break
					}

					message.conversationCount = reader.int32()
					continue
				}
				case 4: {
					if (tag !== 32) {
						break
					}

					message.projectCount = reader.int32()
					continue
				}
				case 5: {
					if (tag !== 40) {
						break
					}

					message.lastUpdated = longToNumber(reader.int64())
					continue
				}
				case 6: {
					if (tag !== 48) {
						break
					}

					message.memoryUsage = longToNumber(reader.int64())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): MemoryStatsResponse {
		return {
			totalMemories: isSet(object.totalMemories) ? globalThis.Number(object.totalMemories) : 0,
			patternsByType: isObject(object.patternsByType)
				? Object.entries(object.patternsByType).reduce<{ [key: string]: number }>((acc, [key, value]) => {
						acc[key] = Number(value)
						return acc
					}, {})
				: {},
			conversationCount: isSet(object.conversationCount) ? globalThis.Number(object.conversationCount) : 0,
			projectCount: isSet(object.projectCount) ? globalThis.Number(object.projectCount) : 0,
			lastUpdated: isSet(object.lastUpdated) ? globalThis.Number(object.lastUpdated) : 0,
			memoryUsage: isSet(object.memoryUsage) ? globalThis.Number(object.memoryUsage) : 0,
		}
	},

	toJSON(message: MemoryStatsResponse): unknown {
		const obj: any = {}
		if (message.totalMemories !== 0) {
			obj.totalMemories = Math.round(message.totalMemories)
		}
		if (message.patternsByType) {
			const entries = Object.entries(message.patternsByType)
			if (entries.length > 0) {
				obj.patternsByType = {}
				entries.forEach(([k, v]) => {
					obj.patternsByType[k] = Math.round(v)
				})
			}
		}
		if (message.conversationCount !== 0) {
			obj.conversationCount = Math.round(message.conversationCount)
		}
		if (message.projectCount !== 0) {
			obj.projectCount = Math.round(message.projectCount)
		}
		if (message.lastUpdated !== 0) {
			obj.lastUpdated = Math.round(message.lastUpdated)
		}
		if (message.memoryUsage !== 0) {
			obj.memoryUsage = Math.round(message.memoryUsage)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<MemoryStatsResponse>, I>>(base?: I): MemoryStatsResponse {
		return MemoryStatsResponse.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<MemoryStatsResponse>, I>>(object: I): MemoryStatsResponse {
		const message = createBaseMemoryStatsResponse()
		message.totalMemories = object.totalMemories ?? 0
		message.patternsByType = Object.entries(object.patternsByType ?? {}).reduce<{ [key: string]: number }>(
			(acc, [key, value]) => {
				if (value !== undefined) {
					acc[key] = globalThis.Number(value)
				}
				return acc
			},
			{},
		)
		message.conversationCount = object.conversationCount ?? 0
		message.projectCount = object.projectCount ?? 0
		message.lastUpdated = object.lastUpdated ?? 0
		message.memoryUsage = object.memoryUsage ?? 0
		return message
	},
}

function createBaseMemoryStatsResponse_PatternsByTypeEntry(): MemoryStatsResponse_PatternsByTypeEntry {
	return { key: "", value: 0 }
}

export const MemoryStatsResponse_PatternsByTypeEntry: MessageFns<MemoryStatsResponse_PatternsByTypeEntry> = {
	encode(message: MemoryStatsResponse_PatternsByTypeEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.key !== "") {
			writer.uint32(10).string(message.key)
		}
		if (message.value !== 0) {
			writer.uint32(16).int32(message.value)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): MemoryStatsResponse_PatternsByTypeEntry {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseMemoryStatsResponse_PatternsByTypeEntry()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.key = reader.string()
					continue
				}
				case 2: {
					if (tag !== 16) {
						break
					}

					message.value = reader.int32()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): MemoryStatsResponse_PatternsByTypeEntry {
		return {
			key: isSet(object.key) ? globalThis.String(object.key) : "",
			value: isSet(object.value) ? globalThis.Number(object.value) : 0,
		}
	},

	toJSON(message: MemoryStatsResponse_PatternsByTypeEntry): unknown {
		const obj: any = {}
		if (message.key !== "") {
			obj.key = message.key
		}
		if (message.value !== 0) {
			obj.value = Math.round(message.value)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<MemoryStatsResponse_PatternsByTypeEntry>, I>>(
		base?: I,
	): MemoryStatsResponse_PatternsByTypeEntry {
		return MemoryStatsResponse_PatternsByTypeEntry.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<MemoryStatsResponse_PatternsByTypeEntry>, I>>(
		object: I,
	): MemoryStatsResponse_PatternsByTypeEntry {
		const message = createBaseMemoryStatsResponse_PatternsByTypeEntry()
		message.key = object.key ?? ""
		message.value = object.value ?? 0
		return message
	},
}

function createBaseGetCurrentProjectMemoryRequest(): GetCurrentProjectMemoryRequest {
	return { metadata: undefined }
}

export const GetCurrentProjectMemoryRequest: MessageFns<GetCurrentProjectMemoryRequest> = {
	encode(message: GetCurrentProjectMemoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentProjectMemoryRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseGetCurrentProjectMemoryRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.metadata = Metadata.decode(reader, reader.uint32())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): GetCurrentProjectMemoryRequest {
		return { metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined }
	},

	toJSON(message: GetCurrentProjectMemoryRequest): unknown {
		const obj: any = {}
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<GetCurrentProjectMemoryRequest>, I>>(base?: I): GetCurrentProjectMemoryRequest {
		return GetCurrentProjectMemoryRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<GetCurrentProjectMemoryRequest>, I>>(object: I): GetCurrentProjectMemoryRequest {
		const message = createBaseGetCurrentProjectMemoryRequest()
		message.metadata =
			object.metadata !== undefined && object.metadata !== null ? Metadata.fromPartial(object.metadata) : undefined
		return message
	},
}

function createBaseProjectMemoryResponse(): ProjectMemoryResponse {
	return {
		projectId: "",
		projectName: "",
		projectPath: "",
		lastUpdated: 0,
		context: undefined,
		learnedPatterns: [],
		conversationSummary: undefined,
		fileStructure: undefined,
		userPreferences: undefined,
	}
}

export const ProjectMemoryResponse: MessageFns<ProjectMemoryResponse> = {
	encode(message: ProjectMemoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.projectId !== "") {
			writer.uint32(10).string(message.projectId)
		}
		if (message.projectName !== "") {
			writer.uint32(18).string(message.projectName)
		}
		if (message.projectPath !== "") {
			writer.uint32(26).string(message.projectPath)
		}
		if (message.lastUpdated !== 0) {
			writer.uint32(32).int64(message.lastUpdated)
		}
		if (message.context !== undefined) {
			ProjectContext.encode(message.context, writer.uint32(42).fork()).join()
		}
		for (const v of message.learnedPatterns) {
			LearnedPattern.encode(v!, writer.uint32(50).fork()).join()
		}
		if (message.conversationSummary !== undefined) {
			ConversationSummary.encode(message.conversationSummary, writer.uint32(58).fork()).join()
		}
		if (message.fileStructure !== undefined) {
			FileStructureMemory.encode(message.fileStructure, writer.uint32(66).fork()).join()
		}
		if (message.userPreferences !== undefined) {
			UserPreferences.encode(message.userPreferences, writer.uint32(74).fork()).join()
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ProjectMemoryResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseProjectMemoryResponse()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.projectId = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.projectName = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.projectPath = reader.string()
					continue
				}
				case 4: {
					if (tag !== 32) {
						break
					}

					message.lastUpdated = longToNumber(reader.int64())
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.context = ProjectContext.decode(reader, reader.uint32())
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.learnedPatterns.push(LearnedPattern.decode(reader, reader.uint32()))
					continue
				}
				case 7: {
					if (tag !== 58) {
						break
					}

					message.conversationSummary = ConversationSummary.decode(reader, reader.uint32())
					continue
				}
				case 8: {
					if (tag !== 66) {
						break
					}

					message.fileStructure = FileStructureMemory.decode(reader, reader.uint32())
					continue
				}
				case 9: {
					if (tag !== 74) {
						break
					}

					message.userPreferences = UserPreferences.decode(reader, reader.uint32())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ProjectMemoryResponse {
		return {
			projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
			projectName: isSet(object.projectName) ? globalThis.String(object.projectName) : "",
			projectPath: isSet(object.projectPath) ? globalThis.String(object.projectPath) : "",
			lastUpdated: isSet(object.lastUpdated) ? globalThis.Number(object.lastUpdated) : 0,
			context: isSet(object.context) ? ProjectContext.fromJSON(object.context) : undefined,
			learnedPatterns: globalThis.Array.isArray(object?.learnedPatterns)
				? object.learnedPatterns.map((e: any) => LearnedPattern.fromJSON(e))
				: [],
			conversationSummary: isSet(object.conversationSummary)
				? ConversationSummary.fromJSON(object.conversationSummary)
				: undefined,
			fileStructure: isSet(object.fileStructure) ? FileStructureMemory.fromJSON(object.fileStructure) : undefined,
			userPreferences: isSet(object.userPreferences) ? UserPreferences.fromJSON(object.userPreferences) : undefined,
		}
	},

	toJSON(message: ProjectMemoryResponse): unknown {
		const obj: any = {}
		if (message.projectId !== "") {
			obj.projectId = message.projectId
		}
		if (message.projectName !== "") {
			obj.projectName = message.projectName
		}
		if (message.projectPath !== "") {
			obj.projectPath = message.projectPath
		}
		if (message.lastUpdated !== 0) {
			obj.lastUpdated = Math.round(message.lastUpdated)
		}
		if (message.context !== undefined) {
			obj.context = ProjectContext.toJSON(message.context)
		}
		if (message.learnedPatterns?.length) {
			obj.learnedPatterns = message.learnedPatterns.map((e) => LearnedPattern.toJSON(e))
		}
		if (message.conversationSummary !== undefined) {
			obj.conversationSummary = ConversationSummary.toJSON(message.conversationSummary)
		}
		if (message.fileStructure !== undefined) {
			obj.fileStructure = FileStructureMemory.toJSON(message.fileStructure)
		}
		if (message.userPreferences !== undefined) {
			obj.userPreferences = UserPreferences.toJSON(message.userPreferences)
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ProjectMemoryResponse>, I>>(base?: I): ProjectMemoryResponse {
		return ProjectMemoryResponse.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ProjectMemoryResponse>, I>>(object: I): ProjectMemoryResponse {
		const message = createBaseProjectMemoryResponse()
		message.projectId = object.projectId ?? ""
		message.projectName = object.projectName ?? ""
		message.projectPath = object.projectPath ?? ""
		message.lastUpdated = object.lastUpdated ?? 0
		message.context =
			object.context !== undefined && object.context !== null ? ProjectContext.fromPartial(object.context) : undefined
		message.learnedPatterns = object.learnedPatterns?.map((e) => LearnedPattern.fromPartial(e)) || []
		message.conversationSummary =
			object.conversationSummary !== undefined && object.conversationSummary !== null
				? ConversationSummary.fromPartial(object.conversationSummary)
				: undefined
		message.fileStructure =
			object.fileStructure !== undefined && object.fileStructure !== null
				? FileStructureMemory.fromPartial(object.fileStructure)
				: undefined
		message.userPreferences =
			object.userPreferences !== undefined && object.userPreferences !== null
				? UserPreferences.fromPartial(object.userPreferences)
				: undefined
		return message
	},
}

function createBaseProjectContext(): ProjectContext {
	return {
		technologies: [],
		frameworks: [],
		languages: [],
		dependencies: {},
		buildTools: [],
		testingFrameworks: [],
		codingStandards: [],
		architecture: [],
	}
}

export const ProjectContext: MessageFns<ProjectContext> = {
	encode(message: ProjectContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.technologies) {
			writer.uint32(10).string(v!)
		}
		for (const v of message.frameworks) {
			writer.uint32(18).string(v!)
		}
		for (const v of message.languages) {
			writer.uint32(26).string(v!)
		}
		Object.entries(message.dependencies).forEach(([key, value]) => {
			ProjectContext_DependenciesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join()
		})
		for (const v of message.buildTools) {
			writer.uint32(42).string(v!)
		}
		for (const v of message.testingFrameworks) {
			writer.uint32(50).string(v!)
		}
		for (const v of message.codingStandards) {
			writer.uint32(58).string(v!)
		}
		for (const v of message.architecture) {
			writer.uint32(66).string(v!)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ProjectContext {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseProjectContext()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.technologies.push(reader.string())
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.frameworks.push(reader.string())
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.languages.push(reader.string())
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					const entry4 = ProjectContext_DependenciesEntry.decode(reader, reader.uint32())
					if (entry4.value !== undefined) {
						message.dependencies[entry4.key] = entry4.value
					}
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.buildTools.push(reader.string())
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.testingFrameworks.push(reader.string())
					continue
				}
				case 7: {
					if (tag !== 58) {
						break
					}

					message.codingStandards.push(reader.string())
					continue
				}
				case 8: {
					if (tag !== 66) {
						break
					}

					message.architecture.push(reader.string())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ProjectContext {
		return {
			technologies: globalThis.Array.isArray(object?.technologies)
				? object.technologies.map((e: any) => globalThis.String(e))
				: [],
			frameworks: globalThis.Array.isArray(object?.frameworks)
				? object.frameworks.map((e: any) => globalThis.String(e))
				: [],
			languages: globalThis.Array.isArray(object?.languages) ? object.languages.map((e: any) => globalThis.String(e)) : [],
			dependencies: isObject(object.dependencies)
				? Object.entries(object.dependencies).reduce<{ [key: string]: string }>((acc, [key, value]) => {
						acc[key] = String(value)
						return acc
					}, {})
				: {},
			buildTools: globalThis.Array.isArray(object?.buildTools)
				? object.buildTools.map((e: any) => globalThis.String(e))
				: [],
			testingFrameworks: globalThis.Array.isArray(object?.testingFrameworks)
				? object.testingFrameworks.map((e: any) => globalThis.String(e))
				: [],
			codingStandards: globalThis.Array.isArray(object?.codingStandards)
				? object.codingStandards.map((e: any) => globalThis.String(e))
				: [],
			architecture: globalThis.Array.isArray(object?.architecture)
				? object.architecture.map((e: any) => globalThis.String(e))
				: [],
		}
	},

	toJSON(message: ProjectContext): unknown {
		const obj: any = {}
		if (message.technologies?.length) {
			obj.technologies = message.technologies
		}
		if (message.frameworks?.length) {
			obj.frameworks = message.frameworks
		}
		if (message.languages?.length) {
			obj.languages = message.languages
		}
		if (message.dependencies) {
			const entries = Object.entries(message.dependencies)
			if (entries.length > 0) {
				obj.dependencies = {}
				entries.forEach(([k, v]) => {
					obj.dependencies[k] = v
				})
			}
		}
		if (message.buildTools?.length) {
			obj.buildTools = message.buildTools
		}
		if (message.testingFrameworks?.length) {
			obj.testingFrameworks = message.testingFrameworks
		}
		if (message.codingStandards?.length) {
			obj.codingStandards = message.codingStandards
		}
		if (message.architecture?.length) {
			obj.architecture = message.architecture
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ProjectContext>, I>>(base?: I): ProjectContext {
		return ProjectContext.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ProjectContext>, I>>(object: I): ProjectContext {
		const message = createBaseProjectContext()
		message.technologies = object.technologies?.map((e) => e) || []
		message.frameworks = object.frameworks?.map((e) => e) || []
		message.languages = object.languages?.map((e) => e) || []
		message.dependencies = Object.entries(object.dependencies ?? {}).reduce<{ [key: string]: string }>(
			(acc, [key, value]) => {
				if (value !== undefined) {
					acc[key] = globalThis.String(value)
				}
				return acc
			},
			{},
		)
		message.buildTools = object.buildTools?.map((e) => e) || []
		message.testingFrameworks = object.testingFrameworks?.map((e) => e) || []
		message.codingStandards = object.codingStandards?.map((e) => e) || []
		message.architecture = object.architecture?.map((e) => e) || []
		return message
	},
}

function createBaseProjectContext_DependenciesEntry(): ProjectContext_DependenciesEntry {
	return { key: "", value: "" }
}

export const ProjectContext_DependenciesEntry: MessageFns<ProjectContext_DependenciesEntry> = {
	encode(message: ProjectContext_DependenciesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.key !== "") {
			writer.uint32(10).string(message.key)
		}
		if (message.value !== "") {
			writer.uint32(18).string(message.value)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ProjectContext_DependenciesEntry {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseProjectContext_DependenciesEntry()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.key = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.value = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ProjectContext_DependenciesEntry {
		return {
			key: isSet(object.key) ? globalThis.String(object.key) : "",
			value: isSet(object.value) ? globalThis.String(object.value) : "",
		}
	},

	toJSON(message: ProjectContext_DependenciesEntry): unknown {
		const obj: any = {}
		if (message.key !== "") {
			obj.key = message.key
		}
		if (message.value !== "") {
			obj.value = message.value
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ProjectContext_DependenciesEntry>, I>>(base?: I): ProjectContext_DependenciesEntry {
		return ProjectContext_DependenciesEntry.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ProjectContext_DependenciesEntry>, I>>(object: I): ProjectContext_DependenciesEntry {
		const message = createBaseProjectContext_DependenciesEntry()
		message.key = object.key ?? ""
		message.value = object.value ?? ""
		return message
	},
}

function createBaseLearnedPattern(): LearnedPattern {
	return {
		id: "",
		type: "",
		description: "",
		pattern: "",
		context: "",
		confidence: 0,
		createdAt: 0,
		lastUsed: 0,
		usageCount: 0,
		tags: [],
	}
}

export const LearnedPattern: MessageFns<LearnedPattern> = {
	encode(message: LearnedPattern, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.id !== "") {
			writer.uint32(10).string(message.id)
		}
		if (message.type !== "") {
			writer.uint32(18).string(message.type)
		}
		if (message.description !== "") {
			writer.uint32(26).string(message.description)
		}
		if (message.pattern !== "") {
			writer.uint32(34).string(message.pattern)
		}
		if (message.context !== "") {
			writer.uint32(42).string(message.context)
		}
		if (message.confidence !== 0) {
			writer.uint32(49).double(message.confidence)
		}
		if (message.createdAt !== 0) {
			writer.uint32(56).int64(message.createdAt)
		}
		if (message.lastUsed !== 0) {
			writer.uint32(64).int64(message.lastUsed)
		}
		if (message.usageCount !== 0) {
			writer.uint32(72).int32(message.usageCount)
		}
		for (const v of message.tags) {
			writer.uint32(82).string(v!)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): LearnedPattern {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseLearnedPattern()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.id = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.type = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.description = reader.string()
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.pattern = reader.string()
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.context = reader.string()
					continue
				}
				case 6: {
					if (tag !== 49) {
						break
					}

					message.confidence = reader.double()
					continue
				}
				case 7: {
					if (tag !== 56) {
						break
					}

					message.createdAt = longToNumber(reader.int64())
					continue
				}
				case 8: {
					if (tag !== 64) {
						break
					}

					message.lastUsed = longToNumber(reader.int64())
					continue
				}
				case 9: {
					if (tag !== 72) {
						break
					}

					message.usageCount = reader.int32()
					continue
				}
				case 10: {
					if (tag !== 82) {
						break
					}

					message.tags.push(reader.string())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): LearnedPattern {
		return {
			id: isSet(object.id) ? globalThis.String(object.id) : "",
			type: isSet(object.type) ? globalThis.String(object.type) : "",
			description: isSet(object.description) ? globalThis.String(object.description) : "",
			pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
			context: isSet(object.context) ? globalThis.String(object.context) : "",
			confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
			createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
			lastUsed: isSet(object.lastUsed) ? globalThis.Number(object.lastUsed) : 0,
			usageCount: isSet(object.usageCount) ? globalThis.Number(object.usageCount) : 0,
			tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
		}
	},

	toJSON(message: LearnedPattern): unknown {
		const obj: any = {}
		if (message.id !== "") {
			obj.id = message.id
		}
		if (message.type !== "") {
			obj.type = message.type
		}
		if (message.description !== "") {
			obj.description = message.description
		}
		if (message.pattern !== "") {
			obj.pattern = message.pattern
		}
		if (message.context !== "") {
			obj.context = message.context
		}
		if (message.confidence !== 0) {
			obj.confidence = message.confidence
		}
		if (message.createdAt !== 0) {
			obj.createdAt = Math.round(message.createdAt)
		}
		if (message.lastUsed !== 0) {
			obj.lastUsed = Math.round(message.lastUsed)
		}
		if (message.usageCount !== 0) {
			obj.usageCount = Math.round(message.usageCount)
		}
		if (message.tags?.length) {
			obj.tags = message.tags
		}
		return obj
	},

	create<I extends Exact<DeepPartial<LearnedPattern>, I>>(base?: I): LearnedPattern {
		return LearnedPattern.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<LearnedPattern>, I>>(object: I): LearnedPattern {
		const message = createBaseLearnedPattern()
		message.id = object.id ?? ""
		message.type = object.type ?? ""
		message.description = object.description ?? ""
		message.pattern = object.pattern ?? ""
		message.context = object.context ?? ""
		message.confidence = object.confidence ?? 0
		message.createdAt = object.createdAt ?? 0
		message.lastUsed = object.lastUsed ?? 0
		message.usageCount = object.usageCount ?? 0
		message.tags = object.tags?.map((e) => e) || []
		return message
	},
}

function createBaseConversationSummary(): ConversationSummary {
	return {
		totalConversations: 0,
		topics: [],
		frequentQuestions: [],
		commonIssues: [],
		successfulSolutions: [],
		lastConversationTopics: [],
	}
}

export const ConversationSummary: MessageFns<ConversationSummary> = {
	encode(message: ConversationSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.totalConversations !== 0) {
			writer.uint32(8).int32(message.totalConversations)
		}
		for (const v of message.topics) {
			writer.uint32(18).string(v!)
		}
		for (const v of message.frequentQuestions) {
			writer.uint32(26).string(v!)
		}
		for (const v of message.commonIssues) {
			writer.uint32(34).string(v!)
		}
		for (const v of message.successfulSolutions) {
			writer.uint32(42).string(v!)
		}
		for (const v of message.lastConversationTopics) {
			writer.uint32(50).string(v!)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ConversationSummary {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseConversationSummary()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break
					}

					message.totalConversations = reader.int32()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.topics.push(reader.string())
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.frequentQuestions.push(reader.string())
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.commonIssues.push(reader.string())
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.successfulSolutions.push(reader.string())
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.lastConversationTopics.push(reader.string())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ConversationSummary {
		return {
			totalConversations: isSet(object.totalConversations) ? globalThis.Number(object.totalConversations) : 0,
			topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e: any) => globalThis.String(e)) : [],
			frequentQuestions: globalThis.Array.isArray(object?.frequentQuestions)
				? object.frequentQuestions.map((e: any) => globalThis.String(e))
				: [],
			commonIssues: globalThis.Array.isArray(object?.commonIssues)
				? object.commonIssues.map((e: any) => globalThis.String(e))
				: [],
			successfulSolutions: globalThis.Array.isArray(object?.successfulSolutions)
				? object.successfulSolutions.map((e: any) => globalThis.String(e))
				: [],
			lastConversationTopics: globalThis.Array.isArray(object?.lastConversationTopics)
				? object.lastConversationTopics.map((e: any) => globalThis.String(e))
				: [],
		}
	},

	toJSON(message: ConversationSummary): unknown {
		const obj: any = {}
		if (message.totalConversations !== 0) {
			obj.totalConversations = Math.round(message.totalConversations)
		}
		if (message.topics?.length) {
			obj.topics = message.topics
		}
		if (message.frequentQuestions?.length) {
			obj.frequentQuestions = message.frequentQuestions
		}
		if (message.commonIssues?.length) {
			obj.commonIssues = message.commonIssues
		}
		if (message.successfulSolutions?.length) {
			obj.successfulSolutions = message.successfulSolutions
		}
		if (message.lastConversationTopics?.length) {
			obj.lastConversationTopics = message.lastConversationTopics
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ConversationSummary>, I>>(base?: I): ConversationSummary {
		return ConversationSummary.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ConversationSummary>, I>>(object: I): ConversationSummary {
		const message = createBaseConversationSummary()
		message.totalConversations = object.totalConversations ?? 0
		message.topics = object.topics?.map((e) => e) || []
		message.frequentQuestions = object.frequentQuestions?.map((e) => e) || []
		message.commonIssues = object.commonIssues?.map((e) => e) || []
		message.successfulSolutions = object.successfulSolutions?.map((e) => e) || []
		message.lastConversationTopics = object.lastConversationTopics?.map((e) => e) || []
		return message
	},
}

function createBaseFileStructureMemory(): FileStructureMemory {
	return { importantFiles: [], frequentlyModified: [], filePurposes: {}, directories: [], entryPoints: [] }
}

export const FileStructureMemory: MessageFns<FileStructureMemory> = {
	encode(message: FileStructureMemory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.importantFiles) {
			writer.uint32(10).string(v!)
		}
		for (const v of message.frequentlyModified) {
			writer.uint32(18).string(v!)
		}
		Object.entries(message.filePurposes).forEach(([key, value]) => {
			FileStructureMemory_FilePurposesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join()
		})
		for (const v of message.directories) {
			writer.uint32(34).string(v!)
		}
		for (const v of message.entryPoints) {
			writer.uint32(42).string(v!)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): FileStructureMemory {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseFileStructureMemory()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.importantFiles.push(reader.string())
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.frequentlyModified.push(reader.string())
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					const entry3 = FileStructureMemory_FilePurposesEntry.decode(reader, reader.uint32())
					if (entry3.value !== undefined) {
						message.filePurposes[entry3.key] = entry3.value
					}
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.directories.push(reader.string())
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.entryPoints.push(reader.string())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): FileStructureMemory {
		return {
			importantFiles: globalThis.Array.isArray(object?.importantFiles)
				? object.importantFiles.map((e: any) => globalThis.String(e))
				: [],
			frequentlyModified: globalThis.Array.isArray(object?.frequentlyModified)
				? object.frequentlyModified.map((e: any) => globalThis.String(e))
				: [],
			filePurposes: isObject(object.filePurposes)
				? Object.entries(object.filePurposes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
						acc[key] = String(value)
						return acc
					}, {})
				: {},
			directories: globalThis.Array.isArray(object?.directories)
				? object.directories.map((e: any) => globalThis.String(e))
				: [],
			entryPoints: globalThis.Array.isArray(object?.entryPoints)
				? object.entryPoints.map((e: any) => globalThis.String(e))
				: [],
		}
	},

	toJSON(message: FileStructureMemory): unknown {
		const obj: any = {}
		if (message.importantFiles?.length) {
			obj.importantFiles = message.importantFiles
		}
		if (message.frequentlyModified?.length) {
			obj.frequentlyModified = message.frequentlyModified
		}
		if (message.filePurposes) {
			const entries = Object.entries(message.filePurposes)
			if (entries.length > 0) {
				obj.filePurposes = {}
				entries.forEach(([k, v]) => {
					obj.filePurposes[k] = v
				})
			}
		}
		if (message.directories?.length) {
			obj.directories = message.directories
		}
		if (message.entryPoints?.length) {
			obj.entryPoints = message.entryPoints
		}
		return obj
	},

	create<I extends Exact<DeepPartial<FileStructureMemory>, I>>(base?: I): FileStructureMemory {
		return FileStructureMemory.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<FileStructureMemory>, I>>(object: I): FileStructureMemory {
		const message = createBaseFileStructureMemory()
		message.importantFiles = object.importantFiles?.map((e) => e) || []
		message.frequentlyModified = object.frequentlyModified?.map((e) => e) || []
		message.filePurposes = Object.entries(object.filePurposes ?? {}).reduce<{ [key: string]: string }>(
			(acc, [key, value]) => {
				if (value !== undefined) {
					acc[key] = globalThis.String(value)
				}
				return acc
			},
			{},
		)
		message.directories = object.directories?.map((e) => e) || []
		message.entryPoints = object.entryPoints?.map((e) => e) || []
		return message
	},
}

function createBaseFileStructureMemory_FilePurposesEntry(): FileStructureMemory_FilePurposesEntry {
	return { key: "", value: "" }
}

export const FileStructureMemory_FilePurposesEntry: MessageFns<FileStructureMemory_FilePurposesEntry> = {
	encode(message: FileStructureMemory_FilePurposesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.key !== "") {
			writer.uint32(10).string(message.key)
		}
		if (message.value !== "") {
			writer.uint32(18).string(message.value)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): FileStructureMemory_FilePurposesEntry {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseFileStructureMemory_FilePurposesEntry()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.key = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.value = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): FileStructureMemory_FilePurposesEntry {
		return {
			key: isSet(object.key) ? globalThis.String(object.key) : "",
			value: isSet(object.value) ? globalThis.String(object.value) : "",
		}
	},

	toJSON(message: FileStructureMemory_FilePurposesEntry): unknown {
		const obj: any = {}
		if (message.key !== "") {
			obj.key = message.key
		}
		if (message.value !== "") {
			obj.value = message.value
		}
		return obj
	},

	create<I extends Exact<DeepPartial<FileStructureMemory_FilePurposesEntry>, I>>(
		base?: I,
	): FileStructureMemory_FilePurposesEntry {
		return FileStructureMemory_FilePurposesEntry.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<FileStructureMemory_FilePurposesEntry>, I>>(
		object: I,
	): FileStructureMemory_FilePurposesEntry {
		const message = createBaseFileStructureMemory_FilePurposesEntry()
		message.key = object.key ?? ""
		message.value = object.value ?? ""
		return message
	},
}

function createBaseUserPreferences(): UserPreferences {
	return {
		codingStyle: "",
		commentingStyle: "",
		namingConventions: [],
		preferredLibraries: [],
		avoidancePatterns: [],
		communicationStyle: "",
	}
}

export const UserPreferences: MessageFns<UserPreferences> = {
	encode(message: UserPreferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.codingStyle !== "") {
			writer.uint32(10).string(message.codingStyle)
		}
		if (message.commentingStyle !== "") {
			writer.uint32(18).string(message.commentingStyle)
		}
		for (const v of message.namingConventions) {
			writer.uint32(26).string(v!)
		}
		for (const v of message.preferredLibraries) {
			writer.uint32(34).string(v!)
		}
		for (const v of message.avoidancePatterns) {
			writer.uint32(42).string(v!)
		}
		if (message.communicationStyle !== "") {
			writer.uint32(50).string(message.communicationStyle)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): UserPreferences {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseUserPreferences()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.codingStyle = reader.string()
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.commentingStyle = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.namingConventions.push(reader.string())
					continue
				}
				case 4: {
					if (tag !== 34) {
						break
					}

					message.preferredLibraries.push(reader.string())
					continue
				}
				case 5: {
					if (tag !== 42) {
						break
					}

					message.avoidancePatterns.push(reader.string())
					continue
				}
				case 6: {
					if (tag !== 50) {
						break
					}

					message.communicationStyle = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): UserPreferences {
		return {
			codingStyle: isSet(object.codingStyle) ? globalThis.String(object.codingStyle) : "",
			commentingStyle: isSet(object.commentingStyle) ? globalThis.String(object.commentingStyle) : "",
			namingConventions: globalThis.Array.isArray(object?.namingConventions)
				? object.namingConventions.map((e: any) => globalThis.String(e))
				: [],
			preferredLibraries: globalThis.Array.isArray(object?.preferredLibraries)
				? object.preferredLibraries.map((e: any) => globalThis.String(e))
				: [],
			avoidancePatterns: globalThis.Array.isArray(object?.avoidancePatterns)
				? object.avoidancePatterns.map((e: any) => globalThis.String(e))
				: [],
			communicationStyle: isSet(object.communicationStyle) ? globalThis.String(object.communicationStyle) : "",
		}
	},

	toJSON(message: UserPreferences): unknown {
		const obj: any = {}
		if (message.codingStyle !== "") {
			obj.codingStyle = message.codingStyle
		}
		if (message.commentingStyle !== "") {
			obj.commentingStyle = message.commentingStyle
		}
		if (message.namingConventions?.length) {
			obj.namingConventions = message.namingConventions
		}
		if (message.preferredLibraries?.length) {
			obj.preferredLibraries = message.preferredLibraries
		}
		if (message.avoidancePatterns?.length) {
			obj.avoidancePatterns = message.avoidancePatterns
		}
		if (message.communicationStyle !== "") {
			obj.communicationStyle = message.communicationStyle
		}
		return obj
	},

	create<I extends Exact<DeepPartial<UserPreferences>, I>>(base?: I): UserPreferences {
		return UserPreferences.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<UserPreferences>, I>>(object: I): UserPreferences {
		const message = createBaseUserPreferences()
		message.codingStyle = object.codingStyle ?? ""
		message.commentingStyle = object.commentingStyle ?? ""
		message.namingConventions = object.namingConventions?.map((e) => e) || []
		message.preferredLibraries = object.preferredLibraries?.map((e) => e) || []
		message.avoidancePatterns = object.avoidancePatterns?.map((e) => e) || []
		message.communicationStyle = object.communicationStyle ?? ""
		return message
	},
}

function createBaseClearProjectMemoryRequest(): ClearProjectMemoryRequest {
	return { metadata: undefined, projectId: "" }
}

export const ClearProjectMemoryRequest: MessageFns<ClearProjectMemoryRequest> = {
	encode(message: ClearProjectMemoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join()
		}
		if (message.projectId !== "") {
			writer.uint32(18).string(message.projectId)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ClearProjectMemoryRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseClearProjectMemoryRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.metadata = Metadata.decode(reader, reader.uint32())
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.projectId = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ClearProjectMemoryRequest {
		return {
			metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
			projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
		}
	},

	toJSON(message: ClearProjectMemoryRequest): unknown {
		const obj: any = {}
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata)
		}
		if (message.projectId !== "") {
			obj.projectId = message.projectId
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ClearProjectMemoryRequest>, I>>(base?: I): ClearProjectMemoryRequest {
		return ClearProjectMemoryRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ClearProjectMemoryRequest>, I>>(object: I): ClearProjectMemoryRequest {
		const message = createBaseClearProjectMemoryRequest()
		message.metadata =
			object.metadata !== undefined && object.metadata !== null ? Metadata.fromPartial(object.metadata) : undefined
		message.projectId = object.projectId ?? ""
		return message
	},
}

function createBaseExportMemoryRequest(): ExportMemoryRequest {
	return { metadata: undefined, projectId: "" }
}

export const ExportMemoryRequest: MessageFns<ExportMemoryRequest> = {
	encode(message: ExportMemoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join()
		}
		if (message.projectId !== "") {
			writer.uint32(18).string(message.projectId)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ExportMemoryRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseExportMemoryRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.metadata = Metadata.decode(reader, reader.uint32())
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.projectId = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ExportMemoryRequest {
		return {
			metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
			projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
		}
	},

	toJSON(message: ExportMemoryRequest): unknown {
		const obj: any = {}
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata)
		}
		if (message.projectId !== "") {
			obj.projectId = message.projectId
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ExportMemoryRequest>, I>>(base?: I): ExportMemoryRequest {
		return ExportMemoryRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ExportMemoryRequest>, I>>(object: I): ExportMemoryRequest {
		const message = createBaseExportMemoryRequest()
		message.metadata =
			object.metadata !== undefined && object.metadata !== null ? Metadata.fromPartial(object.metadata) : undefined
		message.projectId = object.projectId ?? ""
		return message
	},
}

function createBaseImportMemoryRequest(): ImportMemoryRequest {
	return { metadata: undefined, projectId: "", memoryJson: "" }
}

export const ImportMemoryRequest: MessageFns<ImportMemoryRequest> = {
	encode(message: ImportMemoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join()
		}
		if (message.projectId !== "") {
			writer.uint32(18).string(message.projectId)
		}
		if (message.memoryJson !== "") {
			writer.uint32(26).string(message.memoryJson)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ImportMemoryRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseImportMemoryRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.metadata = Metadata.decode(reader, reader.uint32())
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.projectId = reader.string()
					continue
				}
				case 3: {
					if (tag !== 26) {
						break
					}

					message.memoryJson = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): ImportMemoryRequest {
		return {
			metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
			projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
			memoryJson: isSet(object.memoryJson) ? globalThis.String(object.memoryJson) : "",
		}
	},

	toJSON(message: ImportMemoryRequest): unknown {
		const obj: any = {}
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata)
		}
		if (message.projectId !== "") {
			obj.projectId = message.projectId
		}
		if (message.memoryJson !== "") {
			obj.memoryJson = message.memoryJson
		}
		return obj
	},

	create<I extends Exact<DeepPartial<ImportMemoryRequest>, I>>(base?: I): ImportMemoryRequest {
		return ImportMemoryRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<ImportMemoryRequest>, I>>(object: I): ImportMemoryRequest {
		const message = createBaseImportMemoryRequest()
		message.metadata =
			object.metadata !== undefined && object.metadata !== null ? Metadata.fromPartial(object.metadata) : undefined
		message.projectId = object.projectId ?? ""
		message.memoryJson = object.memoryJson ?? ""
		return message
	},
}

function createBaseAnalyzeConversationRequest(): AnalyzeConversationRequest {
	return { metadata: undefined, messages: [] }
}

export const AnalyzeConversationRequest: MessageFns<AnalyzeConversationRequest> = {
	encode(message: AnalyzeConversationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join()
		}
		for (const v of message.messages) {
			writer.uint32(18).string(v!)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeConversationRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseAnalyzeConversationRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.metadata = Metadata.decode(reader, reader.uint32())
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.messages.push(reader.string())
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): AnalyzeConversationRequest {
		return {
			metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
			messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => globalThis.String(e)) : [],
		}
	},

	toJSON(message: AnalyzeConversationRequest): unknown {
		const obj: any = {}
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata)
		}
		if (message.messages?.length) {
			obj.messages = message.messages
		}
		return obj
	},

	create<I extends Exact<DeepPartial<AnalyzeConversationRequest>, I>>(base?: I): AnalyzeConversationRequest {
		return AnalyzeConversationRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<AnalyzeConversationRequest>, I>>(object: I): AnalyzeConversationRequest {
		const message = createBaseAnalyzeConversationRequest()
		message.metadata =
			object.metadata !== undefined && object.metadata !== null ? Metadata.fromPartial(object.metadata) : undefined
		message.messages = object.messages?.map((e) => e) || []
		return message
	},
}

function createBaseGetRelevantContextRequest(): GetRelevantContextRequest {
	return { metadata: undefined, query: "" }
}

export const GetRelevantContextRequest: MessageFns<GetRelevantContextRequest> = {
	encode(message: GetRelevantContextRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join()
		}
		if (message.query !== "") {
			writer.uint32(18).string(message.query)
		}
		return writer
	},

	decode(input: BinaryReader | Uint8Array, length?: number): GetRelevantContextRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
		const end = length === undefined ? reader.len : reader.pos + length
		const message = createBaseGetRelevantContextRequest()
		while (reader.pos < end) {
			const tag = reader.uint32()
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break
					}

					message.metadata = Metadata.decode(reader, reader.uint32())
					continue
				}
				case 2: {
					if (tag !== 18) {
						break
					}

					message.query = reader.string()
					continue
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break
			}
			reader.skip(tag & 7)
		}
		return message
	},

	fromJSON(object: any): GetRelevantContextRequest {
		return {
			metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
			query: isSet(object.query) ? globalThis.String(object.query) : "",
		}
	},

	toJSON(message: GetRelevantContextRequest): unknown {
		const obj: any = {}
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata)
		}
		if (message.query !== "") {
			obj.query = message.query
		}
		return obj
	},

	create<I extends Exact<DeepPartial<GetRelevantContextRequest>, I>>(base?: I): GetRelevantContextRequest {
		return GetRelevantContextRequest.fromPartial(base ?? ({} as any))
	},
	fromPartial<I extends Exact<DeepPartial<GetRelevantContextRequest>, I>>(object: I): GetRelevantContextRequest {
		const message = createBaseGetRelevantContextRequest()
		message.metadata =
			object.metadata !== undefined && object.metadata !== null ? Metadata.fromPartial(object.metadata) : undefined
		message.query = object.query ?? ""
		return message
	},
}

/** MemoryService provides methods for managing memory */
export type MemoryServiceDefinition = typeof MemoryServiceDefinition
export const MemoryServiceDefinition = {
	name: "MemoryService",
	fullName: "cline.MemoryService",
	methods: {
		getMemoryStats: {
			name: "GetMemoryStats",
			requestType: GetMemoryStatsRequest,
			requestStream: false,
			responseType: MemoryStatsResponse,
			responseStream: false,
			options: {},
		},
		getCurrentProjectMemory: {
			name: "GetCurrentProjectMemory",
			requestType: GetCurrentProjectMemoryRequest,
			requestStream: false,
			responseType: ProjectMemoryResponse,
			responseStream: false,
			options: {},
		},
		clearProjectMemory: {
			name: "ClearProjectMemory",
			requestType: ClearProjectMemoryRequest,
			requestStream: false,
			responseType: StringValue,
			responseStream: false,
			options: {},
		},
		exportMemory: {
			name: "ExportMemory",
			requestType: ExportMemoryRequest,
			requestStream: false,
			responseType: StringValue,
			responseStream: false,
			options: {},
		},
		importMemory: {
			name: "ImportMemory",
			requestType: ImportMemoryRequest,
			requestStream: false,
			responseType: StringValue,
			responseStream: false,
			options: {},
		},
		analyzeConversation: {
			name: "AnalyzeConversation",
			requestType: AnalyzeConversationRequest,
			requestStream: false,
			responseType: StringValue,
			responseStream: false,
			options: {},
		},
		getRelevantContext: {
			name: "GetRelevantContext",
			requestType: GetRelevantContextRequest,
			requestStream: false,
			responseType: StringValue,
			responseStream: false,
			options: {},
		},
	},
} as const

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends { $case: string }
				? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
				: T extends {}
					? { [K in keyof T]?: DeepPartial<T[K]> }
					: Partial<T>

type KeysOfUnion<T> = T extends T ? keyof T : never
type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never }

function longToNumber(int64: { toString(): string }): number {
	const num = globalThis.Number(int64.toString())
	if (num > globalThis.Number.MAX_SAFE_INTEGER) {
		throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER")
	}
	if (num < globalThis.Number.MIN_SAFE_INTEGER) {
		throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER")
	}
	return num
}

function isObject(value: any): boolean {
	return typeof value === "object" && value !== null
}

function isSet(value: any): boolean {
	return value !== null && value !== undefined
}

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter
	decode(input: BinaryReader | Uint8Array, length?: number): T
	fromJSON(object: any): T
	toJSON(message: T): unknown
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T
}
